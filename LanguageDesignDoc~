New Language - SC meets Cinder meets OSCthulhu meets Live-coding meets Haskell

-Interpreted
-Dynamically Typed
-Infix
-No semi colons or commas

Types:

bool
Number 
String
Array
Function
Monad
Namespace/Module?
Primitive
Variable

Need:
-Dynamic Scope! 
-Always pass by value
-Streams/Patterns
-Maybe,IO,Networking
-Include everything?
-Lazy Evaluation + Promises. C++-11:
"In C++11 such lazy futures can be created by passing the std::launch::sync launch policy to std::async, along with the function to compute the value."

Syntax:

Define a Function:
doubleMe x = 
	x + x

mulShit x y = x * y

Use a Function:
doubleMe( 2 3 )

Array:
[0 1 2 3]
WE NEED HASKELL LIKE ARRAY FUNCTIONS, i.e.:
Here, for example, is a definition of an array of the squares of numbers from 1 to 100: 
squares =  array (1,100) [(i, i*i) | i <- [1..100]]

Control Structure:
nthElement :: [a] -> Int -> Maybe a 
nthElement [] a = Nothing
nthElement (x:xs) a 	: a <= 0 = Nothing
			: a == 1 = Just x
                    	: a > 1 = nthElement xs (a-1)
			. = Nothing //default case



// Garbage Collection

Allocate memory on a heap? Just use new?
Store pointers in a table or linked list or heap with references pointing to eachother.

At the beginning of the Mark, find the roots. Roots are everything in the dynamic scope stack. Then traverse the tree/heap/whatever finding all the "live" objects. When done collect the "dead" objects, remove duplicate entries, then free all the data. Afterwards add all the live objects back to the "AllObjects" set.

Considerations: Compaction, using 2 heaps and switching between them to avoid fragmentation.
use handles instead of pointers?
Ours will be simpler because we pass by value.

