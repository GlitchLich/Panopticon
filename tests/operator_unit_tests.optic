//Unit Tests

//An interesting idea....We could have a function library, this library would be compiled at startup, and would follow rules similar to Pure functional languages: Any functions/Values (which are functions in reality) are immutable and cannot be redefined. Furthermore they are immutable even at runtime. However, one may define functions / values at run time which are mutable. Would serve our two purposes (composed pieces and live coding) well.

//Switches? Guards? Pattern Matching?
//Array Slicing? first five elements: a[:5],last five elements, a[5:],
//every other elements, a[::2], 1 through 3 a[1::3]

//Undeclare Variables throw errors:
n*m+z
n*m+z

a = [0 1 2 3]
a + 1
axe x = x
axe(7)
recursion x t = recursion(x t-1)

recursion(12)




headTailFunc z (x:xs) = x : xs

guardTest x
	| x == 0 	= 0
	| x == 1 	= [ 1 2 3 ]
	_			= 10000

guardTest(0)
guardTest(1)
guardTest([5 5])

arrayGuard x
	| x[0] == 1 							= "Zero!"
	| x[1] == 1								= "First!"
	| x[2] == 1								= "Second!"
	| x[0] == 0 && x[1] == 0 && x[2] == 0 	= ["DEAD" "DEAD" "DEAD"]
	_										= "NEIN!"

arrayGuard([1 1 1])
arrayGuard([0 1 1])
arrayGuard([0 0 1])
arrayGuard([0 0 0])
arrayGuard([6 6 6])
arrayGuard(2)
arrayGuard([ [1 0 0] [0 1 0] [0 0 1] ])


//Composition operator WORKS
//Takes up same amount of space, but looks waaaaaay clearer IMO
//Pass expression on the left as the first argument to the func on the right:
f x = x * 2
f(2)
7 >> f

//Chains to other functions:
g x = x * 4
g( f( 1 ) )
f( 1 ) >> g
f( 1 ) >> g()
g( f( g( f( g( f([2 3 4 5]) ) ) ) ) )
[2 3 4 5] >> f >> g >> f >> g >> f >> g

//Partial application also works :) Inserts into the first argument:
f2 x y = x * y
g2 x y = (x * 2) / y
g2( f2( 2 3 ) * 4 10 )
2 >> f2( 3 ) * 4 >> g2( 10 )

//embedable into other functions as well:
embededStream x y = x >> y
embededStream(3 g)
g(3)

//embedable into other functions as well:
embededStream2 x y = x >> y(2)
embededStream2(10 g2)
g2(10 2)

//Composition operator plus guards plus recursion, interesting patterns
crossTheStreams x
	| x < 100 && x > 0	= crossTheStreams(x + 2) - 1 >> crossTheStreams
	_					= x * 2
crossTheStreams(1)
crossTheStreams(50)
crossTheStreams(95)
crossTheStreams(96)
crossTheStreams(97)
crossTheStreams(98)
crossTheStreams(99)
crossTheStreams(100)
crossTheStreams([100 100])

//Function Arrays
// Works
doubler x = x * 2
zeroOut x = x * 0
doubleNeg x = x * (-2)
spreader = [doubler zeroOut doubleNeg]
spreader[0](1)
spreader[](0)
spreader[](2)
spreader[]([0 1 2 3 4 5 6 7 8 9 10])
spreader[]([0 1 2 3 4 5 6 7 8 9 10])[0]
spreader[]([0 1 2 3 4 5 6 7 8 9 10])[1]
spreader[]([0 1 2 3 4 5 6 7 8 9 10])[2][6]
spreader[](spreader[](spreader[](24)))

notRight = 10
notASpreader = [notRight doubleNeg]
notASpreader[](2)

doubleDoubleNeg x y = [x * (-2) y * (-2)]
notEnoughArgs = [doubleNeg doubleDoubleNeg]
notEnoughArgs[](2)


//================
//Unary operators
//================

//Unary Minus
(-3)
//this is math in an array:
[1 -3]
//this is an array with two numbers:
[1 (-3)]

//Not
!true == false

//Bit NOT
~1

//with arrays
![true false true]
(-[0 1 2 3])
~[0 1 2 3]

//Prepending

//Raw Prepend, Right associative, inserts INTO array
1:>2:>3:>4
//or
1:2:3:4

[666] :> [2 3 4]
//or
[666] : [2 3 4]

myArray = [ 2 3 4 5 ]
47 : myArray[0]

1 : 1
1 : true
1 : "hey"
1 : [2 3 4]

true : 1
true : false
true : "hey"
true : [2 3 4]

"hey" : 1
"hey" : true
"hey" : "hey"
"hey" : [2 3 4]

[2 3 4] : 1
[2 3 4] : true
[2 3 4] : "hey"
[2 3 4] : [2 3 4]


//Raw Append, Left associative, inserts INTO array
1 <: 2 <: 3 <: 4
[2 3 4] <: [666]

1 <: 1
1 <: true
1 <: "hey"
1 <: [2 3 4]

true <: 1
true <: false
true <: "hey"
true <: [2 3 4]

"hey" <: 1
"hey" <: true
"hey" <: "hey"
"hey" <: [2 3 4]

[2 3 4] <: 1
[2 3 4] <: true
[2 3 4] <: "hey"
[2 3 4] <: [2 3 4]

printArray = print([0 1 2 3])
printArray
//Concat, Left associative, puts things at same level
//When concacting with strings, creates a new string (but Array takes precedence).
1::2::3::4
[666] :: [ 2 3 4 ]
//or
[666] ++ [2 3 4]

1::1
1::true
1::"hey"
1::[2 3 4]

true::1
true::false
true::"hey"
true::[2 3 4]

"hey"::1
"hey"::true
"hey"::"hey"
"hey"::[2 3 4]

[2 3 4]::1
[2 3 4]::true
[2 3 4]::"hey"
[2 3 4]::[2 3 4]

prependFunc x array = x : array
prependFunc(20 [0 1 2 3])
prependFunc([true false] [0 1 2 3])

prependFunc2 p x y = [ p x ] : y
prependFunc2(20 [0 1 2 3] [0 1 2 3] )

prependFunc3 x array = x*2 :> array+20
prependFunc3(20 [0 1 2 3])

prependFunc4 array = array[0] :> array
prependFunc4([0 1 2 3])

appendFunc array = array <: array[0]
appendFunc([0 1 2 3])

simplePrependLoop x a t
	| t > 0 	= x : simplePrependLoop(x a t-1)
	_			= a
simplePrependLoop(0 [0 1 2 3] 3)

simpleAppendLoop x a t
	| t > 0 	= simpleAppendLoop(x a t-1) <: x
	_			= a
simpleAppendLoop(0 [0 1 2 3] 10)

//Non Destructive
pArray = [ 0 1 2 3 ]
prependFunc("test" pArray)
pArray

//Still non destructive
"test2" : pArray
pArray

//Simply rebuilds the list * 2
//(x:xs) Head and Tail pattern matching 
//(can use any names you want, x:xs is standard however
headTailFunc (x:xs) = change : headTilFunc(xs)
	where
		change = x * 2
//Head only pattern matching
headTailFunc2 (x:xs) = x : xs

//Tail only pattern matching
headTailFunc3 (_:xs) = x : xs

//Where
subvariable = x * z
	where
		z = x+1
		x = 10+1
		
subvariable + [1 2]

arrayWhere = x * z  + [1 2]
	where
		x = 10
		z = 11

subvariable + subvariable / [ subvariable * 3.141592654 ]

arrayWhere

//Where
whereFunc x = x + w - t
	where 
		w = 5
		t = w * x

whereFunc( 3 )
whereArray = [ whereFunc( 11 ) whereFunc( 11 ) ] 
whereArray

//Where with sub functions
subFunc x y = ( x + w ) - ( t(x y) - y ) 
	where 
		w = 5
		t z d = ( z * d ) / 10

subFunc( 13 10 )
subFunc( [ 13 ] 10 )
subFunc( 8 120 )

//Dynamic Scoping in action
subFunc2 x y = t(x y)
	where 
		t y x = x - y

subFunc2( 1 2 )
subFunc2( [ 1 2 ] 2 )
subFunc2( [ 3 2 2 ] 2 )

// Arrays in where statement
subFunc3 x y = t(x y)
	where 
		t y x = [ x y ]

subFunc3( 1 2 )

testFunc x y = [ x y ]
subFunc4 x y = t( x y )
	where 
		t y x = testFunc( y x )

subFunc4( 1 2 )

subvariable = x * z
	where
		x = 10
		z = 11

t w z = w - z
subFunc5 x y = t(x y) * [ 1 2 ]
subFunc5( 1 2 )

subFunc6 x y = [ 2 ]
	where 
		t w = w * 2
		z = 1

subFunc6( 1 2 )

//Arrays with sub functions crashes
subFunc3 x y= t(x y)
	where 
		t y x = [ x y ]

subFunc3( 1 2 )

//Arrays with sub functions crashes
subFunc3 x y= t(x y) + [ 1 2 ]
	where 
		t w z = w - z

subFunc3( 1 2 )
	

chain x = x + y + z + q + w
	where
		y = 1
		z = 2
		q = 3
		w = 4

chain(3)


chain2 x y = p( x )
	where
		p x = print( x )

chain2( [ 3  1 ] 2 )


whereGuardz x
	| x + y > 4 	= [0 1 2 3] * 3
	| x + y == 4 	= 2
	_				= 1
	where
		y = 1
whereGuardz(2)


//Where statements with guard statements
whereGuard x
	| x + y > 10	= 10000
	| x + y == 10	= 10
	_				= 0
	where
		y = 5

whereGuard( 5 )

arrayGuard x
	| x[0] == 1	= "First"
	| x[1] == 1 = "Second"
	_			= "nope"

arrayGuard([12 11 2])

//Fibonacci sequence! probably shouldn't go above 16 right now....
fib i
    | i > 1  = fib( i-1 ) + fib( i-2 )
    | i == 1 = 1
	| i == 0 = 0
	_ 		 = "fib: negative index"

fList s t
	| s >= t	= fib(s) : []
	| s > 0		= fib(s) : fList(s + 1 t)
	_			= []

fList( 1 13 )

//()'s disband the offside rule
myGuardFunc(
	6 
	0
)

myGuardFunc(2 2)
myGuardFunc(3 2)


//Can Match to different types, produce different types
myGuardFunc3 x 
	| x == "hey" 	= "Hell yeah" 
	| x == 3 		= x^4

myGuardFunc3("hey")
myGuardFunc3(3)
//Throws an error, because no conditions are met. Be careful about this!
myGuardFunc3(0)

//Recursive guards. This way you can make recursion STOP. haha....
factorial n
	| n <= 0 	= 1
	_ 			= n * factorial(n -1)

factorial(1)
factorial(5)
factorial(10)
factorial(20)
factorial(200)
//Speed Test (though printing doesn't help....)
factorial(2000)

//Not working
myCaseFunc x = 
	case x of
		0 -> 1
		1 -> 2
		_ -> 4
		case x of
			0 -> 1
			1 -> 2
			_ -> 4

letFunc x = 
	let	
		w = 2000 + x 
		z = 399/x
	in x + w * z		
)

//Guard version, needs logic:
plusOne x = x + 1
funcRepeater op x t 
	| t > 0 = x + funcRepeater(op op(x) t-1)
	_		= x+op(x)

funcRepeater(plusOne 2 5)

//Works
combiner x y = [x y]
combiner(12 13)

//Arrays with variables in Function declarations
combinedPlus x y i1 i2 = [ x[i1] y[i2] ] + 1
combinedPlus([2 3 4] [4 5 6] 0 2)

separatedPlus x = x[0]+1
anArray = [14 15 16]
separatedPlus(anArray)

getIndex x = x[0]

getIndex([2 3 4])

//parentheses with operations
pL = 10*(2+1)
pL()
pR x y = (x+y)*10
pR(1 1)

ten = 5+5
ten
10+ten
ten+10
twenty = ten + 10
twenty

//variables, crashes needs lexical scoping
num = 5
otherNum = num*33.3
num * otherNum

mybool = true
myfalsebool = !mybool
myfalsebool != mybool

//INDEXING ARRAYS
myArray = [23 22 0 20+1]
myArray[0]
myArray[1]
myArray[2]
myArray[3]
myArray[[[3 1]]]
myArray[myArray[myArray[2]+2]+1]

//Multi-dimensional Array
nestedarray = [ 23 [ 22 21 [ "three" "four" [ "beer" "is good" [ true false ] ] ] ] 20 ]
nestedarray[1]
nestedarray[1][2]
nestedarray[1][2][2]
nestedarray[1][2][2][2]
nestedarray[1][2][2][2][0]

myArray

metaArray = [0 1 myArray 3]
metaArray[2]
metaArray[2][3]

//Indexing in function calls
//Index a previously declared array
valueAtIndex i = myArray[i]
valueAtIndex(3)
//Index a local variable...
valueAtIndex2 a i = a[i]
valueAtIndex2( [3 4 5 6] 2 )
valueAtIndex2( myArray 1 )
//Calling another Function which indexes an array
superLazyIndexing aFunc a i = aFunc(a() i)
superLazyIndexing( valueAtIndex2 myArray 3 )

//Array functions used for Function Calls
myFunc x y = x / y
multiArray = [23 22 [ 0 4 [ 6 7 ] ] 20]
myFunc(2 multiArray)
myFunc(multiArray[2][2][1] multiArray[2])

//Functions as arguments to Function calls
ten = 10
doubler x = x*2
doubler(ten)
doubler(myArray)

//Incorrect number of arguments throws an error.
myFunc(1 2)

//Non-existent Functions throw errors.
myFun(10 11)

"hey"[0]
4[0]
true[0]
myArray["hey"]
myArray[true]
myArray[4]

//PLUS
4 + 4
4 + true
4 + "hey"
4 + [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

"hey" + 4
"hey" + true
"hey" + "hey"
"hey" + [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

true + 4
true + false
true + "hey"
true +  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [true 2 [3 "hey"] 5 [6 7] ] 8] + 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] + false
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] + "hey"
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] + [0 [true 2 [3 "hey"] 5 [6 7] ] 8]
[0 [1 2 [3 4] 5 [6 7] ] 8] + [0 [1 2 [3 4] 5 [6 7] ] 8]

//MINUS
4 - 4
4 - true
4 - "hey"
4 - [0 [true 2 [3 "hey"] 5 [6 7] ] 8]
4 - [0 [1 2 [3 6] 5 [6 7] ] 8]

"hey" - 4
"hey" - true
"hey" - "h"
"hey" - [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" - ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true - 4
true - false
true - "hey"
true -  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] - 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] - false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] - "h"
[0 [1 2 [3 4] 5 [6 7] ] 8] - [0 [1 2 [3 4] 5 [6 7] ] 8]

//MULTIPLY
4 * 4
4 * true
4 * "hey"
4 * [0 [true 2 [3 "hey"] 5 [6 7] ] 8]
4 * [0 [1 2 [3 6] 5 [6 7] ] 8]

"hey" * 4
"hey" * true
"hey" * "h"
"hey" * [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" * ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true * 4
true * false
true * "hey"
true *  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] * 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] * false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] * "h"
mulArrays = [0 [1 2 [3 4] 5 [6 7] ] 8] * [0 [1 2 [3 4] 5 [6 7] ] 8]
mulArrays
//DIVIDE
4 / 4.5
4 / true
4 / "hey"
4 / [1 [true 2 [3 "hey"] 5 [6 7] ] 8]
4 / [1 [1 2 [3 6] 5 [6 7] ] 8]

"hey" / 4
"hey" / true
"hey" / "h"
"hey" / [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" / ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true / 4
true / false
true / "hey"
true /  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] / 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] / false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] / "h"
[0 [1 2 [3 4] 5 [6 7] ] 8] / [1 [1 2 [3 4] 5 [6 7] ] 8]

//MOD
4 % 1.25
4 % true
4 % "hey"
4 % [1 [true 2 [3 "hey"] 5 [6 7] ] 8]
4 % [1 [1 2 [3 6] 5 [6 7] ] 8]

"hey" % 4
"hey" % true
"hey" % "h"
"hey" % [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" % ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true % 4
true % false
true % "hey"
true %  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] % 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] % false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] % "h"
[0 [1 2 [3 4] 5 [6 7] ] 8] % [1 [1 2 [3 4] 5 [6 7] ] 8]

//POW
4 ^ 1.25
4 ^ true
4 ^ "hey"
4 ^ [1 [true 2 [3 "hey"] 5 [6 7] ] 8]
4 ^ [1 [1 2 [3 6] 5 [6 7] ] 8]

"hey" ^ 4
"hey" ^ true
"hey" ^ "h"
"hey" ^ [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" ^ ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true ^ 4
true ^ false
true ^ "hey"
true ^  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] ^ 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] ^ false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] ^ "h"
[0 [1 2 [3 4] 5 [6 7] ] 8] ^ [1 [1 2 [3 4] 5 [6 7] ] 8]

//EQUALTO
4 == 4
4 == 1.25
4 == true
4 == "hey"
4 == [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
4 == [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" == 4
"hey" == true
"hey" == "h"
"hey" == "hey"
"hey" < "hey"
"hey" < "heyhey"
"hey" > "hey"
"hey" > "heyhey"
"hey" <= "hey"
"hey" <= "heyhey"
"hey" >= "hey"
"hey" >= "heyhey"
"hey" == [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" == ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]
"hey" > ["1" ["123" "12" ["12345" "1234"] "123" ["12" "1"] ] "1234"]
"hey" < ["1" ["123" "12" ["12345" "1234"] "123" ["12" "1"] ] "1234"]
"hey" >= ["1" ["123" "12" ["12345" "1234"] "123" ["12" "1"] ] "1234"]
"hey" <= ["1" ["123" "12" ["12345" "1234"] "123" ["12" "1"] ] "1234"]
["1" ["123" "12" ["12345" "1234"] "123" ["12" "1"] ] "1234"] < "hey"
["1" ["123" "12" ["12345" "1234"] "123" ["12" "1"] ] "1234"] > "hey"
["1" ["123" "12" ["12345" "1234"] "123" ["12" "1"] ] "1234"] <= "hey"
["1" ["123" "12" ["12345" "1234"] "123" ["12" "1"] ] "1234"] >= "hey"


true == 4
true == true
true == false
true == "hey"
true ==  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] == 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] == false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] == "h"
[0 [1 2 [3 4] 5 [6 7] ] 8] == [1 [1 2 [3 4] 5 [6 7] ] 8]

//NOTEQUALTO
4 != 4
4 != 1.25
4 != true
4 != "hey"
4 != [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
4 != [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" != 4
"hey" != true
"hey" != "h"
"hey" != "hey"
"hey" != [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" != ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true != 4
true != true
true != false
true != "hey"
true !=  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] != 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] != false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] != "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] != [1 [1 2 [3 4] 5 [6 7] ] 8]

//LESSTHAN
4 < 4
4 < 1.25
4 < true
4 < "hey"
4 < [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
4 < [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" < 4
"hey" < true
"hey" < "h"
"hey" < "hey"
"hey" < [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" < ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true < 4
true < true
true < false
true < "hey"
true <  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] < 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] < false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] < "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] < [1 [1 2 [3 4] 5 [6 7] ] 8]

//GREATERTHAN
4 > 4
4 > 1.25
4 > true
4 > "hey"
4 > [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
4 > [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" > 4
"hey" > true
"hey" > "h"
"hey" > "hey"
"hey" > [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" > ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true > 4
true > true
true > false
true > "hey"
true >  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] > 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] > false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] > "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] > [1 [1 2 [3 4] 5 [6 7] ] 8]

//LESSTHAN
4 <= 4
4 <= 1.25
4 <= true
4 <= "hey"
4 <= [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
4 <= [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" <= 4
"hey" <= true
"hey" <= "h"
"hey" <= "hey"
"hey" <= [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" <= ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true <= 4
true <= true
true <= false
true <= "hey"
true <= [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] <= 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] <= false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] <= "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] <= [1 [1 2 [3 4] 5 [6 7] ] 8]

//GREATERTHAN
4 >= 4
4 >= 1.25
4 >= true
4 >= "hey"
4 >= [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
4 >= [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" >= 4
"hey" >= true
"hey" >= "h"
"hey" >= "hey"
"hey" >= [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" >= ["e" ["h" "y" ["ey" "he"] "h" ["heyyyyyy" " "] ] "3"]

true >= 4
true >= true
true >= false
true >= "hey"
true >=  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] >= 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] >= false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] >= "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] >= [1 [1 2 [3 4] 5 [6 7] ] 8]

//AND
4 && 4
4 && 0
4 && true
4 && "hey"
4 && [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
4 && [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" && 4
"hey" && true
"hey" && "h"
"hey" && "hey"
"hey" && [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" && ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

-3
true && 4
true && true
true && false
true && "hey"
true &&  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] && 4
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] && false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] && "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] && [1 [1 2 [3 4] 5 [6 7] ] 8]

//OR
4 || 4
0 || 0
4 || true
4 || "hey"
4 || [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
4 || [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" || 4
"hey" || true
"hey" || "h"
"hey" || "hey"
"hey" || [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" || ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true || 4
true || true
true || false
true || "hey"
true ||  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] || 0
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] || false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] || "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] || [1 [1 2 [3 4] 5 [6 7] ] 8]

//NOT
!4
!"hey"
!true
![0 1 2 3]

//<<
4 << 4
2 << 1
4 << true
4 << "hey"
4 << [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
4 << [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" << 4
"hey" << true
"hey" << "h"
"hey" << "hey"
"hey" << [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" << ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true << 4
true << true
true << false
true << "hey"
true <<  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] << 2
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] << false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] << "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] << [1 [1 2 [3 4] 5 [6 7] ] 8]

//>>>
4 >>> 4
2 >>> 1
4 >>> true
4 >>> "hey"
4 >>> [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
4 >>> [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" >>> 4
"hey" >>> true
"hey" >>> "h"
"hey" >>> "hey"
"hey" >>> [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" >>> ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true >>> 4
true >>> true
true >>> false
true >>> "hey"
true >>>  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] << 2
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] >> false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] >> "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] >>> [1 [1 2 [3 4] 5 [6 7] ] 8]

//&
4 & 4
2 & 1
4 & true
4 & "hey"
4 & [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
2 & [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" & 4
"hey" & true
"hey" & "h"
"hey" & "hey"
"hey" & [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" & ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true & 4
true & true
true & false
true & "hey"
true &  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] & 3
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] & false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] & "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] & [1 [1 2 [3 4] 5 [6 7] ] 8]

//Bit Or
4 | 4
2 | 1
4 | true
4 | "hey"
4 | [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
2 | [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" | 4
"hey" | true
"hey" | "h"
"hey" | "hey"
"hey" | [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" | ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true | 4
true | true
true | false
true | "hey"
true |  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] | 3
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] | false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] | "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] | [1 [1 2 [3 4] 5 [6 7] ] 8]

//Bit XOR
4 ^| 3
2 ^| 1
4 ^| true
4 ^| "hey"
4 ^| [1 [true 2 [4 "hey"] 5 [6 7] ] 8]
2 ^| [1 [1 2 [3 6] 5 [6 7] ] 4]

"hey" ^| 4
"hey" ^| true
"hey" ^| "h"
"hey" ^| "hey"
"hey" ^| [0 [1 2 [3 6] 5 [6 7] ] 8]
"hey" ^| ["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "3"]

true ^| 4
true ^| true
true ^| false
true ^| "hey"
true ^|  [0 [true 2 [3 "hey"] 5 [6 7] ] 8]

[0 [1 2 [3 4] 5 [6 7] ] 8] ^| 3
[0 [true 2 [3 "hey"] 5 [6 7] ] 8] ^| false
["e" ["h" "y" ["ey" "he"] "h" ["hey" " "] ] "e"] ^| "h"
[1 [1 2 [3 4] 5 [6 7] ] 8] ^| [2 [1 2 [3 4] 5 [6 7] ] 8]

//Bit NOT
~1
~2
~3
~4
~5
~6
~17
~"hey"
~true
~[0 1 2 3]

//=====================================
//Experimental Syntax
//=====================================

//Maps
< >
mapTest = ["test" = 4 "other test" = 5 ]
mapTest["test"]
mapTest["other test"]

myMap = map( "test" = 4
			"other test" 5
			"final test" = 6)


